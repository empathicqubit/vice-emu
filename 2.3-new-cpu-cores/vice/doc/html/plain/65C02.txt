This document is inteded for the following purposes:

- to list and explain the differences between the NMOS 6502 and the CMOS 65C02.
- to list and explain the differences between the 65SC02, the R65C02 and the
  WDC65C02.
- to keep track and document which parts have been emulated and tested in the
  65C02core.c file.


The 65(S)C02 is in many ways like the 6502, but it has additional
instructions, has additional addressing modes and fixes most (if not all) of
the 'quirks' of the 6502. All of the (legal/documented) 6502 opcodes are
also available in the 65(S)C02, and some of the previously illegal/undocumented
opcodes are now new opcodes. Any 'unused' opcodes have been replaced with NOP's
of different lengths and cycles.

Below is a list of opcodes that remained unchanged (no additional cycles or
changes in behaviour) from the 6502:

opcode	mnemonic
------	--------
00      BRK
01	ORA ($nn,X)
05	ORA $nn
06	ASL $nn
08	PHP
09	ORA #$nn
0a	ASL A
0d	ORA $nnnn
0e	ASL $nnnn
10	BPL $nnnn
11	ORA ($nn),Y
15	ORA $nn,X
16	ASL $nn,X
18	CLC
19	ORA $nnnn,Y
1d	ORA $nnnn,X
20	JSR $nnnn
21	AND ($nn,X)
24	BIT $nn
25	AND $nn
26	ROL $nn
28	PLP
29	AND #$nn
2a	ROL A
2c	BIT $nnnn
2d	AND $nnnn
2e	ROL $nnnn
30	BMI $nnnn
31	AND ($nn),Y
35	AND $nn,X
36	ROL $nn,X
38	SEC
39	AND $nnnn,Y
3d	AND $nnnn,X
40	RTI
41	EOR ($nn,X)
45	EOR $nn
46	LSR $nn
48	PHA
49	EOR #$nn
4a	LSR A
4c	JMP $nnnn
4d	EOR $nnnn
4e	LSR $nnnn
50	BVC $nnnn
51	EOR ($nn),Y
55	EOR $nn,X
56	LSR $nn,X
58	CLI
59	EOR $nnnn,Y
5d	EOR $nnnn,X
60	RTS
66	ROR $nn
68	PLA
6a	ROR A
6e	ROR $nnnn
70	BVS $nnnn
76	ROR $nn,X
78	SEI
81	STA ($nn,X)
84	STY $nn
85	STA $nn
86	STX $nn
88	DEY
8a	TXA
8c	STY $nnnn
8d	STA $nnnn
8e	STX $nnnn
90	BCC $nnnn
91	STA ($nn),Y
94	STY $nn,X
95	STA $nn,X
96	STX $nn,Y
98	TYA
99	STA $nnnn,Y
9a	TXS
9d	STA $nnnn,X
a0	LDY #$nn
a1	LDA ($nn,X)
a2	LDX #$nn
a4	LDY $nn
a5	LDA $nn
a6	LDX $nn
a8	TAY
a9	LDA #$nn
aa	TAX
ac	LDY $nnnn
ad	LDA $nnnn
ae	LDX $nnnn
b0	BCS $nnnn
b1	LDA ($nn),Y
b4	LDY $nn,X
b5	LDA $nn,X
b6	LDX $nn,Y
b8	CLV
b9	LDA $nnnn,Y
ba	TSX
bc	LDY $nnnn,X
bd	LDA $nnnn,X
be	LDX $nnnn,Y
c0	CPY #$nn
c1	CMP ($nn,X)
c4	CPY $nn
c5	CMP $nn
c6	DEC $nn
c8	INY
c9	CMP #$nn
ca	DEX
cc	CPY $nnnn
cd	CMP $nnnn
ce	DEC $nnnn
d0	BNE $nnnn
d1	CMP ($nn),Y
d5	CMP $nn,X
d6	DEC $nn,X
d8	CLD
d9	CMP $nnnn,Y
dd	CMP $nnnn,X
de	DEC $nnnn,X
e0	CPX #$nn
e4	CPX $nn
e6	INC $nn
e8	INX
ea	NOP
ec	CPX $nnnn
ee	INC $nnnn
f0	BEQ $nnnn
f6	INC $nn,X
f8	SED
fe	INC $nnnn,X


The normal NOP is 1 byte and uses 2 cycles, with the 65(S)C02 a new kind of
NOP has been introduced, it is 1 byte long and uses 1 cycle, below are the
opcodes that are defined as this single NOP:

opcode	mnemonic	bytes	cycles
------	--------	-----	------
03	NOOP		1	1
0b	NOOP		1	1
13	NOOP		1	1
1b	NOOP		1	1
23	NOOP		1	1
2b	NOOP		1	1
33	NOOP		1	1
3b	NOOP		1	1
43	NOOP		1	1
4b	NOOP		1	1
53	NOOP		1	1
5b	NOOP		1	1
63	NOOP		1	1
6b	NOOP		1	1
73	NOOP		1	1
7b	NOOP		1	1
83	NOOP		1	1
8b	NOOP		1	1
93	NOOP		1	1
9b	NOOP		1	1
a3	NOOP		1	1
ab	NOOP		1	1
b3	NOOP		1	1
bb	NOOP		1	1
c3	NOOP		1	1
d3	NOOP		1	1
e3	NOOP		1	1
eb	NOOP		1	1
f3	NOOP		1	1
fb	NOOP		1	1


The other unused opcodes are defined as >1 byte and >1 cycle NOPs, they are
listed below with their 'suspected' addressing modes:

opcode	mnemonic	bytes	cycles	comments
------	--------	-----	------	--------
02	NOOP #$nn	2	2
22	NOOP #$nn	2	2
42	NOOP #$nn	2	2
44	NOOP $nn	2	2
54	NOOP $nn,X	2	4
5c	NOOP ???	3	8
62	NOOP #$nn	2	2
82	NOOP #$nn	2	2
c2	NOOP #$nn	2	2
d4	NOOP $nn,X	2	4
dc	NOOP $nnnn	3	4
e2	NOOP #$nn	2	2
f4	NOOP $nn,X	2	4
fc	NOOP $nnnn	3	4

Note that the 3 bytes/8 cycles NOP can't really be explained with a normal
addressing mode.


The 65C02 has some extra instructions for stack manipulating with a register
other than the accumulator, these instructions are listed below:

opcode	mnemonic	bytes	cycles	comments
------	--------	-----	------	--------
5a	PHY		1	3	push the Y register onto the stack
7a	PLY		1	4	pull the Y register from the stack
da	PHX		1	3	push the X register onto the stack
fa	PLX		1	4	pull the X register from the stack


The INC and DEC instructions have been extended to be used on the accumulator,
in the same way that INX/INY and DEX/DEY work, the opcodes are listed below:

opcode	mnemonic	bytes	cycles	comments
------	--------	-----	------	--------
1a	INC A		1	2	increment accumulator
3a	DEC A		1	2	decrement accumulator


A new instruction to store the value '0' (much like has been introduced, it
works in much the same way as STA/STX/STY, the opcodes are listed below:

opcode	mnemonic	bytes	cycles
------	--------	-----	------
64	STZ $nn		2	3
74	STZ $nn,X	2	4
9c	STZ $nnnn	3	4
9e	STZ $nnnn,X	3	5


In binary mode (when the D flag is 0) ADC and SBC behave exactly the same as
on the 6502. In decimal mode (when the D flag is 1), the N, V, and Z flag
results are valid (in addition to the accumulator and C flag result) on the
65C02, on the 6502, only the accumulator and C flag results were valid.
The Z flag is set when the accumulator is zero, and cleared when the
accumulator is any other value (including when the accumulator is not a valid
BCD number). The N flag indicates whether bit 7 of the result is set or clear.

The opcodes of the 'fixed' instructions are below:

opcode	mnemonic	bytes	cycles	comments
------	--------	-----	------	--------
61	ADC ($nn,X)	2	6(/7)	+1 decimal mode
65	ADC $nn		2	3(/4)	+1 decimal mode
69	ADC #$nn	2	2(/3)	+1 decimal mode
6d	ADC $nnnn	3	4(/5)	+1 decimal mode
71	ADC ($nn),Y	2	5(/6/7)	+1 decimal mode, +1 page crossing
72	ADC ($nn)	2	5(/6)	+1 decimal mode
75	ADC $nn,X	2	4(/5)	+1 decimal mode
79	ADC $nnnn,Y	3	4(/5/6)	+1 decimal mode, +1 page crossing
7d	ADC $nnnn,X	3	4(/5/6)	+1 decimal mode, +1 page crossing
e1	SBC ($nn,X)	2	6(/7)	+1 decimal mode
e5	SBC $nn		2	3(/4)	+1 decimal mode
e9	SBC #$nn	2	2(/3)	+1 decimal mode
ed	SBC $nnnn	3	4(/5)	+1 decimal mode
f1	SBC ($nn),Y	2	5(/6/7)	+1 decimal mode, +1 page crossing
f2	SBC ($nn)	2	5(/6)	+1 decimal mode
f5	SBC $nn,X	2	4(/5)	+1 decimal mode
f9	SBC $nnnn,Y	3	4(/5/6)	+1 decimal mode, +1 page crossing
fd	SBC $nnnn,X	3	4(/5/6)	+1 decimal mode, +1 page crossing

Note that opcodes 72 and f2 have a new addressing mode which will be explained
next.


A new addressing mode has been introduced, the zeropage indexed mode, it is
like the zeropage y ((zp),Y) mode when Y is zero, and has the same cycle
count. The opcodes using the new addressing mode are listed below:

opcode	mnemonic	bytes	cycles	comments
------	--------	-----	------	--------
12	ORA ($nn)	2	5
32	AND ($nn)	2	5
52	EOR ($nn)	2	5
72	ADC ($nn)	2	5(/6)	+1 decimal mode
92	STA ($nn)	2	5
b2	LDA ($nn)	2	5
d2	CMP ($nn)	2	5
f2	SBC ($nn)	2	5(/6)	+1 decimal mode


The BIT instruction has three additional addressing modes. The $nnnn,X and $nn,X
addressing modes affect the same flags that the abs and zp addressing modes
do. The immediate addressing mode only affects the Z flag. Below is a list:

opcode	mnemonic	bytes	cycles	comments
------	--------	-----	------	--------
34	BIT $nn,X	2	4
3c	BIT $nnnn,X	3	4(/5)	+1 crossing page boundry
89	BIT #$nn	2	2


The JMP instruction has a new ($nnnn,X) addressing mode, the X register is
added to the absolute address, and the resulting address contains the address
to jump to, low byte first:

opcode	mnemonic	bytes	cycles
------	--------	-----	------
7c	JMP ($nnnn,X)	3	6


On the 6502, JMP ($nnnn) had a bug when the low byte of the address was $FF,
the page was not incremented and the second byte would be taken from the same
page but at location $00, for example JMP($09FF) would get the first byte from
$09FF and the second byte from $0900. On the 65(S)C02 this bug is fixed, at the
cost of an extra cycle:

opcode	mnemonic	bytes	cycles
------	--------	-----	------
6c	JMP ($nnnn)	3	6


The 65(S)C02 has a new branch instructio, BRA (branch always), the cycle count
is the same as for the other branch instruction except for the fact that the
condition is always true, and therefore the case of not taking the branch
doesn't exist, and so the minimum cycles for this branch is 3:

opcode	mnemonic	bytes	cycles
------	--------	-----	------
80	BRA $nnnn	2	3(/4)	+1 for crossing page boundry


The 65(S)C02 has two extra instructions for manipulating bits in memory, the
TRB - (test and reset bits) and TSB (test and set bits) instructions. Each
ANDs the memory location with the accumulator and sets the Z flag according to
the result and then bits in the memory location are reset/set according to
which bits in the accumulator are set:

opcode	mnemonic	bytes	cycles
------	--------	-----	------
04	TSB $nn		2	5
0c	TSB $nnnn	3	6
14	TRB $nn		2	5
1c	TRB $nnnn	3	6


The R65C02 and WDC65C02 have 4 additional instructions that are not present in
the 65SC02, BBR* (branch on bit reset), BBS* (branch on bit set), RMB*
(reset memory bit) and SMB* (set memory bit). The BBR* and BBS* are branch
instructions and branch on the condition of a certain bit. The RMB* and SMB*
functions reset/set a certain bit of a memory location. The following opcodes
are used:

opcode	mnemonic	bytes	cycles	comments
------	--------	-----	------	--------
07	RMB0 $nn	2	5	on WDC65C02 and R65C02
0f	BBR0 $nn,$nnnn	3	5	on WDC65C02 and R65C02
17	RMB1 $nn	2	5	on WDC65C02 and R65C02
1f	BBR1 $nn,$nnnn	3	5	on WDC65C02 and R65C02
27	RMB2 $nn	2	5	on WDC65C02 and R65C02
2f	BBR2 $nn,$nnnn	3	5	on WDC65C02 and R65C02
37	RMB3 $nn	2	5	on WDC65C02 and R65C02
3f	BBR3 $nn,$nnnn	3	5	on WDC65C02 and R65C02
47	RMB4 $nn	2	5	on WDC65C02 and R65C02
4f	BBR4 $nn,$nnnn	3	5	on WDC65C02 and R65C02
57	RMB5 $nn	2	5	on WDC65C02 and R65C02
5f	BBR5 $nn,$nnnn	3	5	on WDC65C02 and R65C02
67	RMB6 $nn	2	5	on WDC65C02 and R65C02
6f	BBR6 $nn,$nnnn	3	5	on WDC65C02 and R65C02
77	RMB7 $nn	2	5	on WDC65C02 and R65C02
7f	BBR7 $nn,$nnnn	3	5	on WDC65C02 and R65C02
87	SMB0 $nn	2	5	on WDC65C02 and R65C02
8f	BBS0 $nn,$nnnn	3	5	on WDC65C02 and R65C02
97	SMB1 $nn	2	5	on WDC65C02 and R65C02
9f	BBS1 $nn,$nnnn	3	5	on WDC65C02 and R65C02
a7	SMB2 $nn	2	5	on WDC65C02 and R65C02
af	BBS2 $nn,$nnnn	3	5	on WDC65C02 and R65C02
b7	SMB3 $nn	2	5	on WDC65C02 and R65C02
bf	BBS3 $nn,$nnnn	3	5	on WDC65C02 and R65C02
c7	SMB4 $nn	2	5	on WDC65C02 and R65C02
cf	BBS4 $nn,$nnnn	3	5	on WDC65C02 and R65C02
d7	SMB5 $nn	2	5	on WDC65C02 and R65C02
df	BBS5 $nn,$nnnn	3	5	on WDC65C02 and R65C02
e7	SMB6 $nn	2	5	on WDC65C02 and R65C02
ef	BBS6 $nn,$nnnn	3	5	on WDC65C02 and R65C02
f7	SMB7 $nn	2	5	on WDC65C02 and R65C02
ff	BBS7 $nn,$nnnn	3	5	on WDC65C02 and R65C02

The opcodes above are single NOPs on the 65SC02:

opcode	mnemonic	bytes	cycles	comments
------	--------	-----	------	--------
07	NOOP		1	1	on 65SC02
0f	NOOP		1	1	on 65SC02
17	NOOP		1	1	on 65SC02
1f	NOOP		1	1	on 65SC02
27	NOOP		1	1	on 65SC02
2f	NOOP		1	1	on 65SC02
37	NOOP		1	1	on 65SC02
3f	NOOP		1	1	on 65SC02
47	NOOP		1	1	on 65SC02
4f	NOOP		1	1	on 65SC02
57	NOOP		1	1	on 65SC02
5f	NOOP		1	1	on 65SC02
67	NOOP		1	1	on 65SC02
6f	NOOP		1	1	on 65SC02
77	NOOP		1	1	on 65SC02
7f	NOOP		1	1	on 65SC02
87	NOOP		1	1	on 65SC02
8f	NOOP		1	1	on 65SC02
97	NOOP		1	1	on 65SC02
9f	NOOP		1	1	on 65SC02
a7	NOOP		1	1	on 65SC02
af	NOOP		1	1	on 65SC02
b7	NOOP		1	1	on 65SC02
bf	NOOP		1	1	on 65SC02
c7	NOOP		1	1	on 65SC02
cf	NOOP		1	1	on 65SC02
d7	NOOP		1	1	on 65SC02
df	NOOP		1	1	on 65SC02
e7	NOOP		1	1	on 65SC02
ef	NOOP		1	1	on 65SC02
f7	NOOP		1	1	on 65SC02
ff	NOOP		1	1	on 65SC02


The WDC65C02 has 2 addtional instructions not present in the R65C02 and
65SC02, STP (stops the cpu) and WAI (stops the cpu and waits for an interrupt
to reactivate the cpu):

opcode	mnemonic	bytes	cycles	comments
------	--------	-----	------	--------
cb	WAI		1	3	on WDC65C02
db	STP		1	3	on WDC65C02

The opcodes above are single NOPs on the R65C02 and 65SC02:

opcode	mnemonic	bytes	cycles	comments
------	--------	-----	------	--------
cb	NOOP		1	1	on R65C02 and 65SC02
db	NOOP		1	1	on R65C02 and 65SC02


On the 6502 the $nnnn,X addressing mode for the INC, DEC, ASL, LSR, ROL and ROR instructions always takes 7 cycles, on the 65(S)C02 the cycles for the ASL, LSR, ROL and ROR instructions are 6 when no page boundry is crossed and 7 when it is crossed. Note that DEC and INC still always take 7 cycles on the 65(S)C02.

opcode	mnemonic	bytes	cycles
------	--------	-----	------
1e	ASL $nnnn,X	3	6(/7)	+1 for page boundry crossing
3e	ROL $nnnn,X	3	6(/7)	+1 for boundry crossing
5e	LSR $nnnn,X	3	6(/7)	+1 for boundry crossing
7e	ROR $nnnn,X	3	6(/7)	+1 for boundry crossing


On the 6502 after an interrupt (BRK, IRQ or NMI) or a reset the decimal flag
was unchanged, the 65(S)C02 clears the decimal flag after an interrupt or
reset, the amount of cycles is the same as on the 6502.


On the 6502 there is a group of instructions (the RMW group) that does 1 read
and 2 writes at the effective address, on the 65(S)C02 this has been changed
to 2 reads and 1 write.


On the 6502 when using the absolute indexed addressing mode a read from an
invalid address could happen, on the 65(S)C02 instead of reading from an
invalid address the last instruction byte is read again.

References used for this document:
http://www.6502.org/tutorials/65c02opcodes.html


The following section is for keeping track of tests of the 65C02 core, a * after an element means it has been successfully tested.

65C02 core emulation and tests:
===============================

opcode	mnemonic	bytes	cycles	mode		changed	65SC02	R65C02	WDC65C02
------	--------	-----	------	----		-------	------	------	--------
00	BRK		2	7	brk		yes	yes	yes	yes
01	ORA ($nn,X)	2	6	ind-x read	no	yes	yes	yes
02	NOOP #$nn	2*	2*	imm read	yes	yes*	yes*	yes*
03	NOOP		1*	1*	imp single	yes	yes*	yes*	yes*
04	TSB $nn		2	5	zp rrw		yes	yes	yes	yes
05	ORA $nn		2	3	zp read		no	yes	yes	yes
06	ASL $nn		2	5	zp rrw		yes	yes	yes	yes
07	RMB0 $nn	2	5	zp rrw		yes	no	yes	yes
07	NOOP		1	1	imp single	yes	yes	no	no
08	PHP		1	3	stack push	no	yes	yes	yes
09	ORA #$nn	2	2	imm read	no	yes	yes	yes
0a	ASL A		1	2	imp		no	yes	yes	yes
0b	NOOP		1*	1*	imp single	yes	yes*	yes*	yes*
0c	TSB $nnnn	3	6	abs rrw		yes	yes	yes	yes
0d	ORA $nnnn	3	4	abs read	no	yes	yes	yes
0e	ASL $nnnn	3	6	abs rrw		yes	yes	yes	yes
0f	BBR0 $nn,$nnnn	3	5	zp-branch	yes	no	yes	yes
0f	NOOP		1	1	imp single	yes	yes	no	no

opcode	mnemonic	bytes	cycles	mode		changed	65SC02	R65C02	WDC65C02
------	--------	-----	------	----		-------	------	------	--------
10	BPL $nnnn	2	2/3/4	branch		no	yes	yes	yes
11	ORA ($nn),Y	2	5/6	ind-y read	yes	yes	yes	yes
12	ORA ($nn)	2	5	ind read	yes	yes	yes	yes
13	NOOP		1*	1*	imp single	yes	yes*	yes*	yes*
14	TRB $nn		2	5	zp rrw		yes	yes	yes	yes
15	ORA $nn,X	2	4	zp-x read	no	yes	yes	yes
16	ASL $nn,X	2	6	zp-x rrw	yes	yes	yes	yes
17	RMB1 $nn	2	5	zp rrw		yes	no	yes	yes
17	NOOP		1	1	imp single	yes	yes	no	no
18	CLC		1	2	imp		no	yes	yes	yes
19	ORA $nnnn,Y	3	4/5	abs-y read	yes	yes	yes	yes
1a	INC A		1	2	imp		yes	yes	yes	yes
1b	NOOP		1*	1*	imp single	yes	yes*	yes*	yes*
1c	TRB $nnnn	3	6	abs rrw		yes	yes	yes	yes
1d	ORA $nnnn,X	3	4/5	abs-x read	yes	yes	yes	yes
1e	ASL $nnnn,X	3	6/7	abs-x rrw	yes	yes	yes	yes
1f	BBR1 $nn,$nnnn	3	5	zp-branch	yes	no	yes	yes
1f	NOOP		1	1	imp single	yes	yes	no	no

opcode	mnemonic	bytes	cycles	mode		changed	65SC02	R65C02	WDC65C02
------	--------	-----	------	----		-------	------	------	--------
20	JSR $nnnn	3	6	abs jsr		no	yes	yes	yes
21	AND ($nn,X)	2	6	ind-x read	no	yes	yes	yes
22	NOOP #$nn	2*	2*	imm		yes	yes*	yes*	yes*
23	NOOP		1*	1*	imp single	yes	yes*	yes*	yes*
24	BIT $nn		2	3	zp read		no	yes	yes	yes
25	AND $nn		2	3	zp read		no	yes	yes	yes
26	ROL $nn		2	5	zp rrw		yes	yes	yes	yes
27	RMB2 $nn	2	5	zp rrw		yes	no	yes	yes
27	NOOP		1	1	imp single	yes	yes	no	no
28	PLP		1	4	stack pull	no	yes	yes	yes
29	AND #$nn	2	2	imm		no	yes	yes	yes
2a	ROL A		1	2	imp		no	yes	yes	yes
2b	NOOP		1*	1*	imp single	yes	yes*	yes*	yes*
2c	BIT $nnnn	3	4	abs read	no	yes	yes	yes
2d	AND $nnnn	3	4	abs read	no	yes	yes	yes
2e	ROL $nnnn	3	6	abs rrw		yes	yes	yes	yes
2f	BBR2 $nn,$nnnn	3	5	zp-branch	yes	no	yes	yes
2f	NOOP		1	1	imp single	yes	yes	no	no

opcode	mnemonic	bytes	cycles	mode		changed	65SC02	R65C02	WDC65C02
------	--------	-----	------	----		-------	------	------	--------
30	BMI $nnnn	2	2/3/4	branch		no	yes	yes	yes
31	AND ($nn),Y	2	5/6	ind-y read	yes	yes	yes	yes
32	AND ($nn)	2	5	ind read	yes	yes	yes	yes
33	NOOP		1*	1*	imp single	yes	yes*	yes*	yes*
34	BIT $nn,X	2	4	zp-x read	yes	yes	yes	yes
35	AND $nn,X	2	4	zp-x read	no	yes	yes	yes
36	ROL $nn,X	2	6	zp-x rrw	yes	yes	yes	yes
37	RMB3 $nn	2	5	zp rrw		yes	no	yes	yes
37	NOOP		1	1	imp single	yes	yes	no	no
38	SEC		1	2	imp		no	yes	yes	yes
39	AND $nnnn,Y	3	4/5	abs-y read	yes	yes	yes	yes
3a	DEC A		1	2	imp		yes	yes	yes	yes
3b	NOOP		1*	1*	imp single	yes	yes*	yes*	yes*
3c	BIT $nnnn,X	3	4/5	abs-x read	yes	yes	yes	yes
3d	AND $nnnn,X	3	4/5	abs-x read	yes	yes	yes	yes
3e	ROL $nnnn,X	3	6/7	abs-x rrw	yes	yes	yes	yes
3f	BBR3 $nn,$nnnn	3	5	zp-branch	yes	no	yes	yes
3f	NOOP		1	1	imp single	yes	yes	no	no

opcode	mnemonic	bytes	cycles	mode		changed	65SC02	R65C02	WDC65C02
------	--------	-----	------	----		-------	------	------	--------
40	RTI		1	6	RTI		no	yes	yes	yes
41	EOR ($nn,X)	2	6	ind-x read	no	yes	yes	yes
42	NOOP #$nn	2*	2*	imm		yes	yes*	yes*	yes*
43	NOOP		1*	1*	imp single	yes	yes*	yes*	yes*
44	NOOP $nn	2*	3*	zp		yes	yes*	yes*	yes*
45	EOR $nn		2	3	zp read		no	yes	yes	yes
46	LSR $nn		2	5	zp rrw		yes	yes	yes	yes
47	RMB4 $nn	2	5	zp rrw		yes	no	yes	yes
47	NOOP		1	1	imp single	yes	yes	no	no
48	PHA		1	3	stack push	no	yes	yes	yes
49	EOR #$nn	2	2	imm		no	yes	yes	yes
4a	LSR A		1	2	imp		no	yes	yes	yes
4b	NOOP		1*	1*	imp single	yes	yes*	yes*	yes*
4c	JMP $nnnn	3	3	abs jmp		no	yes	yes	yes
4d	EOR $nnnn	3	4	abs read	no	yes	yes	yes
4e	LSR $nnnn	3	6	abs rrw		yes	yes	yes	yes
4f	BBR4 $nn,$nnnn	3	5	zp-branch	yes	no	yes	yes
4f	NOOP		1	1	imp single	yes	yes	no	no

opcode	mnemonic	bytes	cycles	mode		changed	65SC02	R65C02	WDC65C02
------	--------	-----	------	----		-------	------	------	--------
50	BVC $nnnn	2	2/3/4	branch		no	yes	yes	yes
51	EOR ($nn),Y	2	5/6	ind-y read	yes	yes	yes	yes
52	EOR ($nn)	2	5	ind read	yes	yes	yes	yes
53	NOOP		1*	1*	imp single	yes	yes*	yes*	yes*
54	NOOP $nn,X	2*	4*	zp-x read	yes	yes*	yes*	yes*
55	EOR $nn,X	2	4	zp-x read	no	yes	yes	yes
56	LSR $nn,X	2	6	zp-x rrw	yes	yes	yes	yes
57	RMB5 $nn	2	5	zp rrw		yes	no	yes	yes
57	NOOP		1	1	imp single	yes	yes	no	no
58	CLI		1	2	imp		no	yes	yes	yes
59	EOR $nnnn,Y	3	4/5	abs-y read	yes	yes	yes	yes
5a	PHY		1	3	stack push	yes	yes	yes	yes
5b	NOOP		1*	1*	imp single	yes	yes*	yes*	yes*
5c	NOOP $nnnn	3	8	unknown		yes	yes	yes	yes
5d	EOR $nnnn,X	3	4/5	abs-x read	yes	yes	yes	yes
5e	LSR $nnnn,X	3	6/7	abs-x rrw	yes	yes	yes	yes
5f	BBR5 $nn,$nnnn	3	5	zp-branch	yes	no	yes	yes
5f	NOOP		1	1	imp single	yes	yes	no	no

opcode	mnemonic	bytes	cycles	mode		changed	65SC02	R65C02	WDC65C02
------	--------	-----	------	----		-------	------	------	--------
60	RTS		1	6	rts		no	yes	yes	yes
61	ADC ($nn,X)	2	6/7	ind-x read	yes	yes	yes	yes
62	NOOP #$nn	2*	2*	imm		yes	yes*	yes*	yes*
63	NOOP		1*	1*	imp single	yes	yes*	yes*	yes*
64	STZ $nn		2	3	zp write	yes	yes	yes	yes
65	ADC $nn		2	3/4	zp read		yes	yes	yes	yes
66	ROR $nn		2	5	zp rrw		yes	yes	yes	yes
67	RMB6 $nn	2	5	zp rrw		yes	no	yes	yes
67	NOOP		1	1	imp single	yes	yes	no	no
68	PLA		1	4	stack pull	no	yes	yes	yes
69	ADC #$nn	2	2/3	imm		yes	yes	yes	yes
6a	ROR A		1	2	imp		no	yes	yes	yes
6b	NOOP		1*	1*	imp single	yes	yes*	yes*	yes*
6c	JMP ($nnnn)	3	6	ind jmp		yes	yes	yes	yes
6d	ADC $nnnn	3	4/5	abs read	yes	yes	yes	yes
6e	ROR $nnnn	3	6	abs rrw		yes	yes	yes	yes
6f	BBR6 $nn,$nnnn	3	5	zp-branch	yes	no	yes	yes
6f	NOOP		1	1	imp single	yes	yes	no	no

opcode	mnemonic	bytes	cycles	mode		changed	65SC02	R65C02	WDC65C02
------	--------	-----	------	----		-------	------	------	--------
70	BVS $nnnn	2	2/3/4	branch		no	yes	yes	yes
71	ADC ($nn),Y	2	5/6/7	ind-y read	yes	yes	yes	yes
72	ADC ($nn)	2	5/6	ind read	yes	yes	yes	yes
73	NOOP		1	1	imp single	yes	yes*	yes*	yes*
74	STZ $nn,X	2	4	zp-x write	yes	yes	yes	yes
75	ADC $nn,X	2	4/5	zp-x read	yes	yes	yes	yes
76	ROR $nn,X	2	6	zp-x rrw	yes	yes	yes	yes
77	RMB7 $nn	2	5	zp rrw		yes	no	yes	yes
77	NOOP		1	1	imp single	yes	yes	no	no
78	SEI		1	2	imp		no	yes	yes	yes
79	ADC $nnnn,Y	3	4/5/6	abs-y read	yes	yes	yes	yes
7a	PLY		1	4	stack pull	yes	yes	yes	yes
7b	NOOP		1*	1*	imp single	yes	yes*	yes*	yes*
7c	JMP ($nnnn,X)	3	6	ind-x jmp	yes	yes	yes	yes
7d	ADC $nnnn,X	3	4/5/6	abs-x read	yes	yes	yes	yes
7e	ROR $nnnn,X	3	6/7	abs-x rrw	yes	yes	yes	yes
7f	BBR7 $nn,$nnnn	3	5	zp-branch	yes	no	yes	yes
7f	NOOP		1	1	imp single	yes	yes	no	no

opcode	mnemonic	bytes	cycles	mode		changed	65SC02	R65C02	WDC65C02
------	--------	-----	------	----		-------	------	------	--------
80	BRA $nnnn	2	3/4	brancg		yes	yes	yes	yes
81	STA ($nn,X)	2	6	ind-x write	no	yes	yes	yes
82	NOP #$nn	2*	2*	imm		yes	yes*	yes*	yes*
83	NOOP		1*	1*	imp single	yes	yes*	yes*	yes*
84	STY $nn		2	3	zp write	no	yes	yes	yes
85	STA $nn		2	3	zp write	no	yes	yes	yes
86	STX $nn		2	3	zp write	no	yes	yes	yes
87	SMB0 $nn	2	5	zp rrw		yes	no	yes	yes
87	NOOP		1	1	imp single	yes	yes	no	no	
88	DEY		1	2	imp		yes	yes	yes	yes
89	BIT #$nn	2	2	imm		yes	yes	yes	yes
8a	TXA		1	2	imp		no	yes	yes	yes
8b	NOOP		1*	1*	imp single	yes	yes*	yes*	yes*
8c	STY $nnnn	3	4	abs write	no	yes	yes	yes
8d	STA $nnnn	3	4	abs write	no	yes	yes	yes
8e	STX $nnnn	3	4	abs write	no	yes	yes	yes
8f	BBS0 $nn,$nnnn	3	5	zp-branch	yes	no	yes	yes
8f	NOOP		1	1	imp single	yes	yes	no	no

opcode	mnemonic	bytes	cycles	mode		changed	65SC02	R65C02	WDC65C02
------	--------	-----	------	----		-------	------	------	--------
90	BCC $nnnn	2	2/3/4	branch		no	yes	yes	yes
91	STA ($nn),Y	2	6	ind-y write	no	yes	yes	yes
92	STA ($nn)	2	5	ind write	yes	yes	yes	yes
93	NOOP		1*	1*	imp single	yes	yes*	yes*	yes*
94	STY $nn,X	2	4	zp-x write	no	yes	yes	yes
95	STA $nn,X	2	4	zp-x write	no	yes	yes	yes
96	STX $nn,Y	2	4	zp-x write	no	yes	yes	yes
97	SMB1 $nn	2	5	zp rrw		yes	no	yes	yes
97	NOOP		1	1	imp single	yes	yes	no	no
98	TYA		1	2	imp		no	yes	yes	yes
99	STA $nnnn,Y	3	5	abs-y write	yes	yes	yes	yes
9a	TXS		1	2	imp		no	yes	yes	yes
9b	NOOP		1*	1*	imp single	yes	yes*	yes*	yes*
9c	STZ $nnnn	3	4	abs write	yes	yes	yes	yes
9d	STA $nnnn,X	3	5	abs-x write	yes	yes	yes	yes
9e	STZ $nnnn,X	3	5	abs-x write	yes	yes	yes	yes
9f	BBS1 $nn,$nnnn	3	5	zp-branch	yes	no	yes	yes
9f	NOOP		1	1	imp single	yes	yes	no	no

opcode	mnemonic	bytes	cycles	mode		changed	65SC02	R65C02	WDC65C02
------	--------	-----	------	----		-------	------	------	--------
a0	LDY #$nn	2	2	imm		no	yes	yes	yes
a1	LDA ($nn,X)	2	6	ind-x read	no	yes	yes	yes
a2	LDX #$nn	2	2	imm		no	yes	yes	yes
a3	NOOP		1*	1*	imp single	yes	yes*	yes*	yes*
a4	LDY $nn		2	3	zp read		no	yes	yes	yes
a5	LDA $nn		2	3	zp read		no 	yes	yes	yes
a6	LDX $nn		2	3	zp read		no	yes	yes	yes
a7	SMB2 $nn	2	5	zp rrw		yes	no	yes	yes
a7	NOOP		1	1	imp single	yes	yes	no	no
a8	TAY		1	2	imp		no	yes	yes	yes
a9	LDA #$nn	2	2	imm		no	yes	yes	yes
aa	TAX		1	2	imp		no	yes	yes	yes
ab	NOOP		1*	1*	imp single	yes	yes*	yes*	yes*
ac	LDY $nnnn	3	4	abs read	no	yes	yes	yes
ad	LDA $nnnn	3	4	abs read	no	yes	yes	yes
ae	LDX $nnnn	3	4	abs read	no	yes	yes	yes
af	BBS2 $nn,$nnnn	3	5	zp-branch	yes	no	yes	yes
af	NOOP		1	1	imp single	yes	yes	no	no

opcode	mnemonic	bytes	cycles	mode		changed	65SC02	R65C02	WDC65C02
------	--------	-----	------	----		-------	------	------	--------
b0	BCS $nnnn	2	2/3/4	branch		no	yes	yes	yes
b1	LDA ($nn),Y	2	5/6	ind-y read	yes	yes	yes	yes
b2	LDA ($nn)	2	5	ind read	yes	yes	yes	yes
b3	NOOP		1*	1*	imp single	yes	yes*	yes*	yes*
b4	LDY $nn,X	2	4	zp-x read	no	yes	yes	yes
b5	LDA $nn,X	2	4	zp-x read	no	yes	yes	yes
b6	LDX $nn,Y	2	4	zp-y read	no	yes	yes	yes
b7	SMB3 $nn	2	5	zp rrw		yes	no	yes	yes
b7	NOOP		1	1	imp single	yes	yes	no	no
b8	CLV		1	2	imp		no	yes	yes	yes
b9	LDA $nnnn,Y	3	4/5	abs-y read	yes	yes	yes	yes
ba	TSX		1	2	imp		no	yes	yes	yes
bb	NOOP		1*	1*	imp single	yes	yes*	yes*	yes*
bc	LDY $nnnn,X	3	4/5	abs-x read	yes	yes	yes	yes
bd	LDA $nnnn,X	3	4/5	abs-x read	yes	yes	yes	yes
be	LDX $nnnn,Y	3	4/5	abs-y read	yes	yes	yes	yes
bf	BBS3 $nn,$nnnn	3	5	zp-branch	yes	no	yes	yes
bf	NOOP		1	1	imp single	yes	yes	no	no

opcode	mnemonic	bytes	cycles	mode		changed	65SC02	R65C02	WDC65C02
------	--------	-----	------	----		-------	------	------	--------
c0	CPY #$nn	2	2	imm		no	yes	yes	yes
c1	CMP ($nn,X)	2	6	ind-x read	no	yes	yes	yes
c2	NOOP #$nn	2*	2*	imm		yes	yes*	yes*	yes*
c3	NOOP		1*	1*	imp single	yes	yes*	yes*	yes*
c4	CPY $nn		2	3	zp read		no	yes	yes	yes
c5	CMP $nn		2	3	zp read		no	yes	yes	yes
c6	DEC $nn		2	5	zp rrw		yes	yes	yes	yes
c7	SMB4 $nn	2	5	zp rrw		yes	no	yes	yes
c7	NOOP		1	1	imp single	yes	yes	no	no
c8	INY		1	2	imp		no	yes	yes	yes
c9	CMP #$nn	2	2	imm		no	yes	yes	yes
ca	DEX		1	2	imp		no	yes	yes	yes
cb	WAI		1	3	wai		yes	no	no	yes
cb	NOOP		1	1	imp single	yes	yes	yes	no
cc	CPY $nnnn	3	4	abs read	no	yes	yes	yes
cd	CMP $nnnn	3	4	abs read	no	yes	yes	yes
ce	DEC $nnnn	3	6	abs rrw		yes	yes	yes	yes
cf	BBS4 $nn,$nnnn	3	5	zp-branch	yes	no	yes	yes
cf	NOOP		1	1	imp single	yes	yes	no	no

opcode	mnemonic	bytes	cycles	mode		changed	65SC02	R65C02	WDC65C02
------	--------	-----	------	----		-------	------	------	--------
d0	BNE $nnnn	2	2/3/4	branch		no	yes	yes	yes
d1	CMP ($nn),Y	2	5/6	ind-y read	yes	yes	yes	yes
d2	CMP ($nn)	2	5	ind read	yes	yes	yes	yes
d3	NOOP		1*	1*	imp single	yes	yes*	yes*	yes*
d4	NOOP $nn,X	2*	4*	zp-x read	yes	yes*	yes*	yes*
d5	CMP $nn,X	2	4	zp-x read	no	yes	yes	yes
d6	DEC $nn,X	2	6	zp-x rrw	yes	yes	yes	yes
d7	SMB5 $nn	2	5	zp rrw		yes	no	yes	yes
d7	NOOP		1	1	imp single	yes	yes	no	no
d8	CLD		1	2	imp		no	yes	yes	yes
d9	CMP $nnnn,Y	3	4/5	abs-y read	yes	yes	yes	yes
da	PHX		1	3	stack push	yes	yes	yes	yes
db	STP		1	3	stp		yes	no	no	yes
db	NOOP		1	1	imp single	yes	yes	yes	no
dc	NOP $nnnn	3*	4*	abs-x read	yes	yes*	yes*	yes*
dd	CMP $nnnn,X	3	4/5	abs-x read	yes	yes	yes	yes
de	DEC $nnnn,X	3	7	abs-x rrw	yes	yes	yes	yes
df	BBS5 $nn,$nnnn	3	5	zp-branch	yes	no	yes	yes
df	NOOP		1	1	imp single	yes	yes	no	no

opcode	mnemonic	bytes	cycles	mode		changed	65SC02	R65C02	WDC65C02
------	--------	-----	------	----		-------	------	------	--------
e0	CPX #$nn	2	2	imm		no	yes	yes	yes
e1	SBC ($nn,X)	2	6/7	ind-x read	yes	yes	yes	yes
e2	NOOP #$nn	2*	2*	imm		yes	yes*	yes*	yes*
e3	NOOP		1*	1*	imp single	yes	yes*	yes*	yes*
e4	CPX $nn		2	3	zp read		no	yes	yes	yes
e5	SBC $nn		2	3/4	zp read		yes	yes	yes	yes
e6	INC $nn		2	5	zp rrw		yes	yes	yes	yes
e7	SMB6 $nn	2	5	zp rrw		yes	no	yes	yes
e7	NOOP		1	1	imp single	yes	yes	no	no
e8	INX		1	2	imp		no	yes	yes	yes
e9	SBC #$nn	2	2/3	imm		yes	yes	yes	yes
ea	NOP		1*	2*	imp		no	yes*	yes*	yes*
eb	NOOP		1*	1*	imp single	yes	yes*	yes*	yes*
ec	CPX $nnnn	3	4	abs read	no	yes	yes	yes
ed	SBC $nnnn	3	4/5	abs read	yes	yes	yes	yes
ee	INC $nnnn	3	6	abs rrw		yes	yes	yes	yes
ef	BBS6 $nn,$nnnn	3	5	zp-branch	yes	no	yes	yes
ef	NOOP		1	1	imp single	yes	yes	no	no

opcode	mnemonic	bytes	cycles	mode		changed	65SC02	R65C02	WDC65C02
------	--------	-----	------	----		-------	------	------	--------
f0	BEQ $nnnn	2	2/3/4	branch		no	yes	yes	yes
f1	SBC ($nn),Y	2	5/6/7	ind-y read	yes	yes	yes	yes
f2	SBC ($nn)	2	5/6	ind read	yes	yes	yes	yes
f3	NOOP		1*	1*	imp single	yes	yes*	yes*	yes*
f4	NOOP $nn,X	2*	4*	zp-x read	yes	yes*	yes*	yes*
f5	SBC $nn,X	2	4/5	zp-x read	yes	yes	yes	yes
f6	INC $nn,X	2	6	zp-x rrw	yes	yes	yes	yes
f7	SMB7 $nn	2	5	zp rrw		yes	no	yes	yes
f7	NOOP		1	1	imp single	yes	yes	no	no
f8	SED		1	2	imp		no	yes	yes	yes
f9	SBC $nnnn,Y	3	4/5/6	abs-y read	yes	yes	yes	yes
fa	PLX		1	4	stack pull	yes	yes	yes	yes
fb	NOOP		1*	1*	imp single	yes	yes*	yes*	yes*
fc	NOOP $nnnn	3*	4*	abs-x read	yes	yes*	yes*	yes*
fd	SBC $nnnn,X	3	4/5/6	abs-x read	yes	yes	yes	yes
fe	INC $nnnn,X	3	7	abs-x rrw	yes	yes	yes	yes
ff	BBS7 $nn,$nnnn	3	5	zp-branch	yes	no	yes	yes
ff	NOOP		1	1	imp single	yes	yes	no	no


65(S)C02 NOP test code
======================

addr   b1   b2   b3   mnemonic   expected output
----   --   --   --   --------   ---------------
E900   78             SEI
E901   A4   FF        LDY $FF
E903   A5   FE        LDA $FE
E905   A2   44        LDX #$44
E907   86   FE        STX $FE
E909   A2   CC        LDX #$CC
E90B   8E   00   EA   STX $EA00
E90E   A2   88        LDX #$88
E910   86   FF        STX $FF
E912   A2   01        LDX #$01
E914   8E   00   E9   STX $E900
E917   02   00        NOOP #$00  read 02 from E917 at 0		*
                                 read 00 from E918 at 1		*
E919   03             NOOP       read 03 from E919 at 2		*
E91A   0B             NOOP       read 0B from E91A at 3		*
E91B   13             NOOP       read 13 from E91B at 4		*
E91C   1B             NOOP       read 1B from E91C at 5		*
E91D   22   01        NOOP #$01  read 22 from E91D at 6		*
                                 read 01 from E91E at 7		*
E91F   23             NOOP       read 23 from E91F at 8		*
E920   2B             NOOP       read 2B from E920 at 9		*
E921   33             NOOP       read 33 from E921 at A		*
E922   3B             NOOP       read 3B from E922 at B		*
E923   42   02        NOOP #$02  read 42 from E923 at C		*
                                 read 02 from E924 at D		*
E925   43             NOOP       read 43 from E925 at E		*
E926   44   FF        NOOP $FF   read 44 from E926 at F		*
                                 read FF from E927 at 10	*
                                 read 88 from FF at 11		*
E928   4B             NOOP       read 4B from E928 at 12	*
E929   53             NOOP       read 53 from E929 at 13	*
E92A   54   FE        NOOP $FE,X read 54 from E92A at 14	*
                                 read fe from E92B at 15	*
                                 read 44 from FE at 16		*
                                 read 88 from FF at 17		*
E92C   5B             NOOP       read 5B from E92C at 18	*
E92D   62   03        NOOP #$03  read 62 from E92D at 19	*
                                 read 03 from E92E at 1A	*
E92F   63             NOOP       read 63 from E92F at 1B	*
E930   6B             NOOP       read 6B from E930 at 1C	*
E931   73             NOOP       read 73 from E931 at 1D	*
E932   7B             NOOP       read 7B from E932 at 1E	*
E933   82   04        NOOP #$04  read 82 from E933 at 1F	*
                                 read 04 from E934 at 20	*
E935   83             NOOP       read 83 from E935 at 21	*
E936   8B             NOOP       read 8B from E936 at 22	*
E937   93             NOOP       read 93 from E937 at 23	*
E938   9B             NOOP       read 9B from E938 at 24	*
E939   A3             NOOP       read A3 from E939 at 25	*
E93A   AB             NOOP       read AB from E93A at 26	*
E93B   B3             NOOP       read B3 from E93B at 27	*
E93C   BB             NOOP       read BB from E93C at 28	*
E93D   C2   05        NOOP #$05  read C2 from E93D at 29	*
                                 read 05 from E93E at 2A	*
E93F   C3             NOOP       read C3 from E93F at 2B	*
E940   D3             NOOP       read D3 from E940 at 2C	*
E941   D4   FE        NOOP $FE,X read D4 from E941 at 2D	*
                                 read FE from E942 at 2E	*
                                 read 44 from FE at 2F		*
                                 read 88 from FF at 30		*
E943   DC   00   EA   NOOP $EA00 read DC from E943 at 31	*
                                 read 00 from E944 at 32	*
                                 read EA from E945 at 33	*
                                 read CC from EA00 at 34	*
E946   E2   06        NOOP #$06  read E2 from E946 at 35	*
                                 read 06 from E947 at 36	*
E948   E3             NOOP       read E3 from E948 at 37	*
E949   EA             NOP        read EA from E949 at 38	*
                                 read EB from E94A at 39	*
E94A   EB             NOOP       read EB from E94A at 3A	*
E94B   F3             NOOP       read F3 from E94B at 3B	*
E94C   F4   FE        NOOP $FE,X read F4 from E94C at 3C	*
                                 read FE from E94D at 3D	*
                                 read 44 from FE at 3E		*
                                 read 88 from FF at 3F		*
E94E   FB             NOOP       read FB from E94E at 40	*
E94F   FC   00   EA   NOOP $EA00 read FC from E94F at 41	*
                                 read 00 from E950 at 42	*
                                 read EA from E951 at 43	*
                                 read CC from EA00 at 44	*
E952   A2   00        LDX #$78   ---
E954   8E   00   E9   STX $E900  ---
E957   85   FE        STA $FE    ---
E959   84   FF        STA $FF    ---
E95B   58             CLI        ---
E95C   60             RTS        ---


65(S)C02 ORA test code
======================

$40 -> E9
$41 -> C0
$80 -> 70 *
$C0 -> 00 *
$C1 -> EA *
$FE -> CC *
$FF -> 02 *
$EA00 -> 60 *
$EA40 -> 50

addr   b1   b2   b3   mnemonic      expected output
----   --   --   --   --------      ---------------
E900   78             SEI
E901   A5   40        LDA $40
E903   48             PHA
E904   A9   E9        LDA #$E9
E906   85   40        STA $40
E908   A5   41        LDA $41
E90A   48             PHA
E90B   A9   C0        LDA #$C0
E90D   85   41        STA $41
E90F   A5   80        LDA $80
E911   48             PHA
E912   A9   70        LDA #$70
E914   85   80        STA $80
E916   A5   C0        LDA $C0
E918   48             PHA
E919   A9   00        LDA #$00
E91B   85   C0        STA $C0
E91D   A5   C1        LDA $C1
E91F   48             PHA
E920   A9   EA        LDA #$EA
E922   85   C1        STA $C1
E924   A5   FE        LDA $FE
E926   48             PHA
E927   A9   CC        LDA #$CC
E929   85   FE        STA $FE
E92B   A5   FF        LDA $FF
E92D   48             PHA
E92E   A9   02        LDA #$02
E930   85   FF        STA $FF
E932   A9   60        LDA #$60
E934   8D   00   EA   STA $EA00
E937   A9   50        LDA #$50
E939   8D   40   EA   STA $EA40
E93C   A2   40        LDX #$40
E93E   A0   01        LDY #$01
E940   98             TYA
E941   8D   00   E9   STA $E900
E944   01   80        ORA ($80,X)   read 01 from E944 at 0
                                    read 80 from E945 at 1
                                    read 70 from 80 at 2
                                    read 00 from C0 at 3
                                    read EA from C1 at 4
                                    read 60 from EA00 at 5
E946   8D   00   EB   STA $EB00     read 8D from E946 at 6
                                    read 00 from E947 at 7
                                    read EB from E948 at 8
                                    wrote 61 to EB00 at 9
E949   98             TYA           read 98 from E949 at A
E94A   05   80        ORA $80       read 05 from E94A at B
                                    read 80 from E94B at C
                                    read 70 from 80 at D
E94C   8D   01   EB   STA $EB01     read 8D from E94C at E
                                    read 01 from E94D at F
                                    read EB from E94E at 10
                                    wrote 71 to EB01 at 11
E94F   98             TYA           read 98 from E94F at 12
E950   09   F0        ORA #$F0      read 09 from E950 at 13
                                    read F0 from E951 at 14
E952   8D   02   EB   STA $EB02     read 8D from E952 at 15
                                    read 02 from E953 at 16
                                    read EB from E954 at 17
                                    wrote F1 to EB02 at 18
E955   98             TYA           read 98 from E955 at 19
E956   0D   00  EA    ORA $EA00     read 0D from E956 at 1A
                                    read 00 from E957 at 1B
                                    read EA from E958 at 1C
                                    read 60 from EA00 at 1D
E959   8D   03   EB   STA $EB03     read 8D from E959 at 1E
                                    read 03 from E95A at 1F
                                    read EB from E95B at 20
                                    wrote 61 to EB03 at 21
E95C   98             TYA           read 98 from E95C at 22
E95D   A2   40        LDY #$40      read A2 from E95D at 23
                                    read 40 from E95E at 24
E95F   11   C0        ORA ($C0),Y   read 11 from E95F at 25
                                    read C0 from E960 at 26
                                    read 00 from C0 at 27
                                    read EA from C1 at 28



11	ORA ($nn),Y	2	5/6	ind-y read	yes	yes	yes	yes

12	ORA ($nn)	2	5	ind read	yes	yes	yes	yes
13	NOOP		1*	1*	imp single	yes	yes*	yes*	yes*
14	TRB $nn		2	5	zp rrw		yes	yes	yes	yes
15	ORA $nn,X	2	4	zp-x read	no	yes	yes	yes
16	ASL $nn,X	2	6	zp-x rrw	yes	yes	yes	yes
17	RMB1 $nn	2	5	zp rrw		yes	no	yes	yes
17	NOOP		1	1	imp single	yes	yes	no	no
18	CLC		1	2	imp		no	yes	yes	yes
19	ORA $nnnn,Y	3	4/5	abs-y read	yes	yes	yes	yes
1a	INC A		1	2	imp		yes	yes	yes	yes
1b	NOOP		1*	1*	imp single	yes	yes*	yes*	yes*
1c	TRB $nnnn	3	6	abs rrw		yes	yes	yes	yes
1d	ORA $nnnn,X	3	4/5	abs-x read	yes	yes	yes	yes
1e	ASL $nnnn,X	3	6/7	abs-x rrw	yes	yes	yes	yes
1f	BBR1 $nn,$nnnn	3	5	zp-branch	yes	no	yes	yes
1f	NOOP		1	1	imp single	yes	yes	no	no

opcode	mnemonic	bytes	cycles	mode		changed	65SC02	R65C02	WDC65C02
------	--------	-----	------	----		-------	------	------	--------
20	JSR $nnnn	3	6	abs jsr		no	yes	yes	yes
21	AND ($nn,X)	2	6	ind-x read	no	yes	yes	yes
22	NOOP #$nn	2*	2*	imm		yes	yes*	yes*	yes*
23	NOOP		1*	1*	imp single	yes	yes*	yes*	yes*
24	BIT $nn		2	3	zp read		no	yes	yes	yes
25	AND $nn		2	3	zp read		no	yes	yes	yes
26	ROL $nn		2	5	zp rrw		yes	yes	yes	yes
27	RMB2 $nn	2	5	zp rrw		yes	no	yes	yes
27	NOOP		1	1	imp single	yes	yes	no	no
28	PLP		1	4	stack pull	no	yes	yes	yes
29	AND #$nn	2	2	imm		no	yes	yes	yes
2a	ROL A		1	2	imp		no	yes	yes	yes
2b	NOOP		1*	1*	imp single	yes	yes*	yes*	yes*
2c	BIT $nnnn	3	4	abs read	no	yes	yes	yes
2d	AND $nnnn	3	4	abs read	no	yes	yes	yes
2e	ROL $nnnn	3	6	abs rrw		yes	yes	yes	yes
2f	BBR2 $nn,$nnnn	3	5	zp-branch	yes	no	yes	yes
2f	NOOP		1	1	imp single	yes	yes	no	no

opcode	mnemonic	bytes	cycles	mode		changed	65SC02	R65C02	WDC65C02
------	--------	-----	------	----		-------	------	------	--------
30	BMI $nnnn	2	2/3/4	branch		no	yes	yes	yes
31	AND ($nn),Y	2	5/6	ind-y read	yes	yes	yes	yes
32	AND ($nn)	2	5	ind read	yes	yes	yes	yes
33	NOOP		1*	1*	imp single	yes	yes*	yes*	yes*
34	BIT $nn,X	2	4	zp-x read	yes	yes	yes	yes
35	AND $nn,X	2	4	zp-x read	no	yes	yes	yes
36	ROL $nn,X	2	6	zp-x rrw	yes	yes	yes	yes
37	RMB3 $nn	2	5	zp rrw		yes	no	yes	yes
37	NOOP		1	1	imp single	yes	yes	no	no
38	SEC		1	2	imp		no	yes	yes	yes
39	AND $nnnn,Y	3	4/5	abs-y read	yes	yes	yes	yes
3a	DEC A		1	2	imp		yes	yes	yes	yes
3b	NOOP		1*	1*	imp single	yes	yes*	yes*	yes*
3c	BIT $nnnn,X	3	4/5	abs-x read	yes	yes	yes	yes
3d	AND $nnnn,X	3	4/5	abs-x read	yes	yes	yes	yes
3e	ROL $nnnn,X	3	6/7	abs-x rrw	yes	yes	yes	yes
3f	BBR3 $nn,$nnnn	3	5	zp-branch	yes	no	yes	yes
3f	NOOP		1	1	imp single	yes	yes	no	no

opcode	mnemonic	bytes	cycles	mode		changed	65SC02	R65C02	WDC65C02
------	--------	-----	------	----		-------	------	------	--------
40	RTI		1	6	RTI		no	yes	yes	yes
41	EOR ($nn,X)	2	6	ind-x read	no	yes	yes	yes
42	NOOP #$nn	2*	2*	imm		yes	yes*	yes*	yes*
43	NOOP		1*	1*	imp single	yes	yes*	yes*	yes*
44	NOOP $nn	2*	3*	zp		yes	yes*	yes*	yes*
45	EOR $nn		2	3	zp read		no	yes	yes	yes
46	LSR $nn		2	5	zp rrw		yes	yes	yes	yes
47	RMB4 $nn	2	5	zp rrw		yes	no	yes	yes
47	NOOP		1	1	imp single	yes	yes	no	no
48	PHA		1	3	stack push	no	yes	yes	yes
49	EOR #$nn	2	2	imm		no	yes	yes	yes
4a	LSR A		1	2	imp		no	yes	yes	yes
4b	NOOP		1*	1*	imp single	yes	yes*	yes*	yes*
4c	JMP $nnnn	3	3	abs jmp		no	yes	yes	yes
4d	EOR $nnnn	3	4	abs read	no	yes	yes	yes
4e	LSR $nnnn	3	6	abs rrw		yes	yes	yes	yes
4f	BBR4 $nn,$nnnn	3	5	zp-branch	yes	no	yes	yes
4f	NOOP		1	1	imp single	yes	yes	no	no

opcode	mnemonic	bytes	cycles	mode		changed	65SC02	R65C02	WDC65C02
------	--------	-----	------	----		-------	------	------	--------
50	BVC $nnnn	2	2/3/4	branch		no	yes	yes	yes
51	EOR ($nn),Y	2	5/6	ind-y read	yes	yes	yes	yes
52	EOR ($nn)	2	5	ind read	yes	yes	yes	yes
53	NOOP		1*	1*	imp single	yes	yes*	yes*	yes*
54	NOOP $nn,X	2*	4*	zp-x read	yes	yes*	yes*	yes*
55	EOR $nn,X	2	4	zp-x read	no	yes	yes	yes
56	LSR $nn,X	2	6	zp-x rrw	yes	yes	yes	yes
57	RMB5 $nn	2	5	zp rrw		yes	no	yes	yes
57	NOOP		1	1	imp single	yes	yes	no	no
58	CLI		1	2	imp		no	yes	yes	yes
59	EOR $nnnn,Y	3	4/5	abs-y read	yes	yes	yes	yes
5a	PHY		1	3	stack push	yes	yes	yes	yes
5b	NOOP		1*	1*	imp single	yes	yes*	yes*	yes*
5c	NOOP $nnnn	3	8	unknown		yes	yes	yes	yes
5d	EOR $nnnn,X	3	4/5	abs-x read	yes	yes	yes	yes
5e	LSR $nnnn,X	3	6/7	abs-x rrw	yes	yes	yes	yes
5f	BBR5 $nn,$nnnn	3	5	zp-branch	yes	no	yes	yes
5f	NOOP		1	1	imp single	yes	yes	no	no

opcode	mnemonic	bytes	cycles	mode		changed	65SC02	R65C02	WDC65C02
------	--------	-----	------	----		-------	------	------	--------
60	RTS		1	6	rts		no	yes	yes	yes
61	ADC ($nn,X)	2	6/7	ind-x read	yes	yes	yes	yes
62	NOOP #$nn	2*	2*	imm		yes	yes*	yes*	yes*
63	NOOP		1*	1*	imp single	yes	yes*	yes*	yes*
64	STZ $nn		2	3	zp write	yes	yes	yes	yes
65	ADC $nn		2	3/4	zp read		yes	yes	yes	yes
66	ROR $nn		2	5	zp rrw		yes	yes	yes	yes
67	RMB6 $nn	2	5	zp rrw		yes	no	yes	yes
67	NOOP		1	1	imp single	yes	yes	no	no
68	PLA		1	4	stack pull	no	yes	yes	yes
69	ADC #$nn	2	2/3	imm		yes	yes	yes	yes
6a	ROR A		1	2	imp		no	yes	yes	yes
6b	NOOP		1*	1*	imp single	yes	yes*	yes*	yes*
6c	JMP ($nnnn)	3	6	ind jmp		yes	yes	yes	yes
6d	ADC $nnnn	3	4/5	abs read	yes	yes	yes	yes
6e	ROR $nnnn	3	6	abs rrw		yes	yes	yes	yes
6f	BBR6 $nn,$nnnn	3	5	zp-branch	yes	no	yes	yes
6f	NOOP		1	1	imp single	yes	yes	no	no

opcode	mnemonic	bytes	cycles	mode		changed	65SC02	R65C02	WDC65C02
------	--------	-----	------	----		-------	------	------	--------
70	BVS $nnnn	2	2/3/4	branch		no	yes	yes	yes
71	ADC ($nn),Y	2	5/6/7	ind-y read	yes	yes	yes	yes
72	ADC ($nn)	2	5/6	ind read	yes	yes	yes	yes
73	NOOP		1	1	imp single	yes	yes*	yes*	yes*
74	STZ $nn,X	2	4	zp-x write	yes	yes	yes	yes
75	ADC $nn,X	2	4/5	zp-x read	yes	yes	yes	yes
76	ROR $nn,X	2	6	zp-x rrw	yes	yes	yes	yes
77	RMB7 $nn	2	5	zp rrw		yes	no	yes	yes
77	NOOP		1	1	imp single	yes	yes	no	no
78	SEI		1	2	imp		no	yes	yes	yes
79	ADC $nnnn,Y	3	4/5/6	abs-y read	yes	yes	yes	yes
7a	PLY		1	4	stack pull	yes	yes	yes	yes
7b	NOOP		1*	1*	imp single	yes	yes*	yes*	yes*
7c	JMP ($nnnn,X)	3	6	ind-x jmp	yes	yes	yes	yes
7d	ADC $nnnn,X	3	4/5/6	abs-x read	yes	yes	yes	yes
7e	ROR $nnnn,X	3	6/7	abs-x rrw	yes	yes	yes	yes
7f	BBR7 $nn,$nnnn	3	5	zp-branch	yes	no	yes	yes
7f	NOOP		1	1	imp single	yes	yes	no	no

opcode	mnemonic	bytes	cycles	mode		changed	65SC02	R65C02	WDC65C02
------	--------	-----	------	----		-------	------	------	--------
80	BRA $nnnn	2	3/4	brancg		yes	yes	yes	yes
81	STA ($nn,X)	2	6	ind-x write	no	yes	yes	yes
82	NOP #$nn	2*	2*	imm		yes	yes*	yes*	yes*
83	NOOP		1*	1*	imp single	yes	yes*	yes*	yes*
84	STY $nn		2	3	zp write	no	yes	yes	yes
85	STA $nn		2	3	zp write	no	yes	yes	yes
86	STX $nn		2	3	zp write	no	yes	yes	yes
87	SMB0 $nn	2	5	zp rrw		yes	no	yes	yes
87	NOOP		1	1	imp single	yes	yes	no	no	
88	DEY		1	2	imp		yes	yes	yes	yes
89	BIT #$nn	2	2	imm		yes	yes	yes	yes
8a	TXA		1	2	imp		no	yes	yes	yes
8b	NOOP		1*	1*	imp single	yes	yes*	yes*	yes*
8c	STY $nnnn	3	4	abs write	no	yes	yes	yes
8d	STA $nnnn	3	4	abs write	no	yes	yes	yes
8e	STX $nnnn	3	4	abs write	no	yes	yes	yes
8f	BBS0 $nn,$nnnn	3	5	zp-branch	yes	no	yes	yes
8f	NOOP		1	1	imp single	yes	yes	no	no

opcode	mnemonic	bytes	cycles	mode		changed	65SC02	R65C02	WDC65C02
------	--------	-----	------	----		-------	------	------	--------
90	BCC $nnnn	2	2/3/4	branch		no	yes	yes	yes
91	STA ($nn),Y	2	6	ind-y write	no	yes	yes	yes
92	STA ($nn)	2	5	ind write	yes	yes	yes	yes
93	NOOP		1*	1*	imp single	yes	yes*	yes*	yes*
94	STY $nn,X	2	4	zp-x write	no	yes	yes	yes
95	STA $nn,X	2	4	zp-x write	no	yes	yes	yes
96	STX $nn,Y	2	4	zp-x write	no	yes	yes	yes
97	SMB1 $nn	2	5	zp rrw		yes	no	yes	yes
97	NOOP		1	1	imp single	yes	yes	no	no
98	TYA		1	2	imp		no	yes	yes	yes
99	STA $nnnn,Y	3	5	abs-y write	yes	yes	yes	yes
9a	TXS		1	2	imp		no	yes	yes	yes
9b	NOOP		1*	1*	imp single	yes	yes*	yes*	yes*
9c	STZ $nnnn	3	4	abs write	yes	yes	yes	yes
9d	STA $nnnn,X	3	5	abs-x write	yes	yes	yes	yes
9e	STZ $nnnn,X	3	5	abs-x write	yes	yes	yes	yes
9f	BBS1 $nn,$nnnn	3	5	zp-branch	yes	no	yes	yes
9f	NOOP		1	1	imp single	yes	yes	no	no

opcode	mnemonic	bytes	cycles	mode		changed	65SC02	R65C02	WDC65C02
------	--------	-----	------	----		-------	------	------	--------
a0	LDY #$nn	2	2	imm		no	yes	yes	yes
a1	LDA ($nn,X)	2	6	ind-x read	no	yes	yes	yes
a2	LDX #$nn	2	2	imm		no	yes	yes	yes
a3	NOOP		1*	1*	imp single	yes	yes*	yes*	yes*
a4	LDY $nn		2	3	zp read		no	yes	yes	yes
a5	LDA $nn		2	3	zp read		no 	yes	yes	yes
a6	LDX $nn		2	3	zp read		no	yes	yes	yes
a7	SMB2 $nn	2	5	zp rrw		yes	no	yes	yes
a7	NOOP		1	1	imp single	yes	yes	no	no
a8	TAY		1	2	imp		no	yes	yes	yes
a9	LDA #$nn	2	2	imm		no	yes	yes	yes
aa	TAX		1	2	imp		no	yes	yes	yes
ab	NOOP		1*	1*	imp single	yes	yes*	yes*	yes*
ac	LDY $nnnn	3	4	abs read	no	yes	yes	yes
ad	LDA $nnnn	3	4	abs read	no	yes	yes	yes
ae	LDX $nnnn	3	4	abs read	no	yes	yes	yes
af	BBS2 $nn,$nnnn	3	5	zp-branch	yes	no	yes	yes
af	NOOP		1	1	imp single	yes	yes	no	no

opcode	mnemonic	bytes	cycles	mode		changed	65SC02	R65C02	WDC65C02
------	--------	-----	------	----		-------	------	------	--------
b0	BCS $nnnn	2	2/3/4	branch		no	yes	yes	yes
b1	LDA ($nn),Y	2	5/6	ind-y read	yes	yes	yes	yes
b2	LDA ($nn)	2	5	ind read	yes	yes	yes	yes
b3	NOOP		1*	1*	imp single	yes	yes*	yes*	yes*
b4	LDY $nn,X	2	4	zp-x read	no	yes	yes	yes
b5	LDA $nn,X	2	4	zp-x read	no	yes	yes	yes
b6	LDX $nn,Y	2	4	zp-y read	no	yes	yes	yes
b7	SMB3 $nn	2	5	zp rrw		yes	no	yes	yes
b7	NOOP		1	1	imp single	yes	yes	no	no
b8	CLV		1	2	imp		no	yes	yes	yes
b9	LDA $nnnn,Y	3	4/5	abs-y read	yes	yes	yes	yes
ba	TSX		1	2	imp		no	yes	yes	yes
bb	NOOP		1*	1*	imp single	yes	yes*	yes*	yes*
bc	LDY $nnnn,X	3	4/5	abs-x read	yes	yes	yes	yes
bd	LDA $nnnn,X	3	4/5	abs-x read	yes	yes	yes	yes
be	LDX $nnnn,Y	3	4/5	abs-y read	yes	yes	yes	yes
bf	BBS3 $nn,$nnnn	3	5	zp-branch	yes	no	yes	yes
bf	NOOP		1	1	imp single	yes	yes	no	no

opcode	mnemonic	bytes	cycles	mode		changed	65SC02	R65C02	WDC65C02
------	--------	-----	------	----		-------	------	------	--------
c0	CPY #$nn	2	2	imm		no	yes	yes	yes
c1	CMP ($nn,X)	2	6	ind-x read	no	yes	yes	yes
c2	NOOP #$nn	2*	2*	imm		yes	yes*	yes*	yes*
c3	NOOP		1*	1*	imp single	yes	yes*	yes*	yes*
c4	CPY $nn		2	3	zp read		no	yes	yes	yes
c5	CMP $nn		2	3	zp read		no	yes	yes	yes
c6	DEC $nn		2	5	zp rrw		yes	yes	yes	yes
c7	SMB4 $nn	2	5	zp rrw		yes	no	yes	yes
c7	NOOP		1	1	imp single	yes	yes	no	no
c8	INY		1	2	imp		no	yes	yes	yes
c9	CMP #$nn	2	2	imm		no	yes	yes	yes
ca	DEX		1	2	imp		no	yes	yes	yes
cb	WAI		1	3	wai		yes	no	no	yes
cb	NOOP		1	1	imp single	yes	yes	yes	no
cc	CPY $nnnn	3	4	abs read	no	yes	yes	yes
cd	CMP $nnnn	3	4	abs read	no	yes	yes	yes
ce	DEC $nnnn	3	6	abs rrw		yes	yes	yes	yes
cf	BBS4 $nn,$nnnn	3	5	zp-branch	yes	no	yes	yes
cf	NOOP		1	1	imp single	yes	yes	no	no

opcode	mnemonic	bytes	cycles	mode		changed	65SC02	R65C02	WDC65C02
------	--------	-----	------	----		-------	------	------	--------
d0	BNE $nnnn	2	2/3/4	branch		no	yes	yes	yes
d1	CMP ($nn),Y	2	5/6	ind-y read	yes	yes	yes	yes
d2	CMP ($nn)	2	5	ind read	yes	yes	yes	yes
d3	NOOP		1*	1*	imp single	yes	yes*	yes*	yes*
d4	NOOP $nn,X	2*	4*	zp-x read	yes	yes*	yes*	yes*
d5	CMP $nn,X	2	4	zp-x read	no	yes	yes	yes
d6	DEC $nn,X	2	6	zp-x rrw	yes	yes	yes	yes
d7	SMB5 $nn	2	5	zp rrw		yes	no	yes	yes
d7	NOOP		1	1	imp single	yes	yes	no	no
d8	CLD		1	2	imp		no	yes	yes	yes
d9	CMP $nnnn,Y	3	4/5	abs-y read	yes	yes	yes	yes
da	PHX		1	3	stack push	yes	yes	yes	yes
db	STP		1	3	stp		yes	no	no	yes
db	NOOP		1	1	imp single	yes	yes	yes	no
dc	NOP $nnnn	3*	4*	abs-x read	yes	yes*	yes*	yes*
dd	CMP $nnnn,X	3	4/5	abs-x read	yes	yes	yes	yes
de	DEC $nnnn,X	3	7	abs-x rrw	yes	yes	yes	yes
df	BBS5 $nn,$nnnn	3	5	zp-branch	yes	no	yes	yes
df	NOOP		1	1	imp single	yes	yes	no	no

opcode	mnemonic	bytes	cycles	mode		changed	65SC02	R65C02	WDC65C02
------	--------	-----	------	----		-------	------	------	--------
e0	CPX #$nn	2	2	imm		no	yes	yes	yes
e1	SBC ($nn,X)	2	6/7	ind-x read	yes	yes	yes	yes
e2	NOOP #$nn	2*	2*	imm		yes	yes*	yes*	yes*
e3	NOOP		1*	1*	imp single	yes	yes*	yes*	yes*
e4	CPX $nn		2	3	zp read		no	yes	yes	yes
e5	SBC $nn		2	3/4	zp read		yes	yes	yes	yes
e6	INC $nn		2	5	zp rrw		yes	yes	yes	yes
e7	SMB6 $nn	2	5	zp rrw		yes	no	yes	yes
e7	NOOP		1	1	imp single	yes	yes	no	no
e8	INX		1	2	imp		no	yes	yes	yes
e9	SBC #$nn	2	2/3	imm		yes	yes	yes	yes
ea	NOP		1*	2*	imp		no	yes*	yes*	yes*
eb	NOOP		1*	1*	imp single	yes	yes*	yes*	yes*
ec	CPX $nnnn	3	4	abs read	no	yes	yes	yes
ed	SBC $nnnn	3	4/5	abs read	yes	yes	yes	yes
ee	INC $nnnn	3	6	abs rrw		yes	yes	yes	yes
ef	BBS6 $nn,$nnnn	3	5	zp-branch	yes	no	yes	yes
ef	NOOP		1	1	imp single	yes	yes	no	no

opcode	mnemonic	bytes	cycles	mode		changed	65SC02	R65C02	WDC65C02
------	--------	-----	------	----		-------	------	------	--------
f0	BEQ $nnnn	2	2/3/4	branch		no	yes	yes	yes
f1	SBC ($nn),Y	2	5/6/7	ind-y read	yes	yes	yes	yes
f2	SBC ($nn)	2	5/6	ind read	yes	yes	yes	yes
f3	NOOP		1*	1*	imp single	yes	yes*	yes*	yes*
f4	NOOP $nn,X	2*	4*	zp-x read	yes	yes*	yes*	yes*
f5	SBC $nn,X	2	4/5	zp-x read	yes	yes	yes	yes
f6	INC $nn,X	2	6	zp-x rrw	yes	yes	yes	yes
f7	SMB7 $nn	2	5	zp rrw		yes	no	yes	yes
f7	NOOP		1	1	imp single	yes	yes	no	no
f8	SED		1	2	imp		no	yes	yes	yes
f9	SBC $nnnn,Y	3	4/5/6	abs-y read	yes	yes	yes	yes
fa	PLX		1	4	stack pull	yes	yes	yes	yes
fb	NOOP		1*	1*	imp single	yes	yes*	yes*	yes*
fc	NOOP $nnnn	3*	4*	abs-x read	yes	yes*	yes*	yes*
fd	SBC $nnnn,X	3	4/5/6	abs-x read	yes	yes	yes	yes
fe	INC $nnnn,X	3	7	abs-x rrw	yes	yes	yes	yes
ff	BBS7 $nn,$nnnn	3	5	zp-branch	yes	no	yes	yes
ff	NOOP		1	1	imp single	yes	yes	no	no
